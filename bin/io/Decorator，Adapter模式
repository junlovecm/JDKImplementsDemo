1适配器模式
        将被适配类的方法扩展成客户目标接口类方法去表示、调用，目的是消除由于接口不匹配所造成类的不兼容问题。
        主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式
    类    适配器模式：将一个类转换成满足另一个新接口的类时，创建Wrapper包装类，继承原有类，实现新的接口即可。
    对象适配器模式：将一个对象转换成满足另一个新接口的对象时，可以创建Wrapper包装类，定义、引入原类实例。
    接口适配器模式：不希望实现一个接口中所有方法时，可创建抽象类Wrapper包装类，实现所有方法，其它实现类继承抽象类并重载去抽取需重写的方法。
    适配器模式组成:
    • 目标角色（Target）：定义Client使用的与特定领域相关的接口。
    • 客户角色（Client）：与符合Target接口的对象协同。
    • 被适配角色（Adaptee)：定义一个已经存在并已经使用的接口，这个接口需要适配。
    • 适配器角色（Adapte) ：适配器模式的核心。它将对被适配Adaptee角色已有的接口转换为目标角色Target匹配的接口。
                                                            对Adaptee的接口与Target接口进行适配.
                                        
2装饰模式（Decorator）
    动态给类进行装饰并增加一些新的功能，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例.
    归纳组成:
    • Component为统一接口，也是装饰类和被装饰类的基本类型.
    • ConcreteComponent为具体实现类，也是被装饰类，他本身是具有一些功能的完整的类.
    • Decorator是装饰类，实现Component接口的同时还在内部维护一个ConcreteComponent的实例，
    	     并可以通过构造函数初始化。而Decorator本身，通常采用默认实现，他的存在仅仅是一个声明：我要生产出一些用于装饰
    	    的子类。而其子类才是赋有具体装饰效果的装饰产品类。
    • ConcreteDecorator是具体的装饰产品类，每一种装饰产品都具有特定的装饰效果。可以通过构造器声明装饰哪种类型的
          ConcreteComponent，从而对其进行装饰。
